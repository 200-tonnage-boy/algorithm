## 定义
- 堆结构就是用数组实现的完全二叉树（不满的只能在最后一层，而且只能是从左往右不满）
  - 对完全二叉树的计算公式来说，有时候根节点从1开始，不从0，是因为可以方便用位运算代替公式；
- 完全二叉树如果每颗子树的最大值都在顶部，大根堆
- 反之小根堆

[0,1,2,3,4,5] 这种连续数组就可以想想为完全二叉树的位置编号；
左孩子的位置编号：2*i+1,右孩子2*i+2;父亲(i-1)/2
如果不从0开始，2*i/2*i+1/i/2 为了使用位运算


问题1：动态创建大根堆：挨个给一个数，如何最终组织成大根堆的形式？
思路：
- 每次插入数据，根据公式看下父位置的大小，如果大于父亲，就交换位置；
- 收了N个数，层数在logN级别，每一步的操作复杂度都是logN

问题2：实现大根堆返回最大值；
思路：
- 取出第一个数字。并将heapSize - 1（也就是数组长度-1）；
- 把最后一个数字放到取出的最大值上；
- heapify操作，从上，利用左右子树公式，与max（z, l）交换，知道越界heapsize
  - left < heapsize while循环终止条件 代表还有孩子节点，左边都越界了证明没孩子了
  - 下沉复杂度还是logN.还是层高；


问题3：堆排序
思路：
- N个数进行堆排
- 就类比每次给一个的操作，for循环，每次进行创建大根堆的操作
- 把0和heapsize交换，并heapsize-1；此时heapsize往后一个位置就是最大值，
- 从0做heapify；
- 递归进行上面两步，知道heapsize为0：即创建个大根堆，取最大值取空为止；
- 复杂度为NlogN,两个操作都是这个复杂度，常数系数省略，空间为常数

问题4：数组创建大根堆的优化操作
思路：
- 倒序进行heapify，从数组末尾开始
- 如何证明时间复杂度比正序heapinsert好？
  - 最后一层有N/2个节点，倒数第二层N/4....N/8   N/16；
  - 每一层进行heapify的复杂度为N/2 (N/4)*2  (N/8)*3... 最终收敛于On 

问题5：已知一个几乎有序的数组，即：如果把数组排好顺序，每个元素移动的距离一定不超过K，且K相对于数组长度来说是比较小的
思路：
- 假设K为5，因此最小值只能在5之前出现，先把这一段弄成小根堆，然后弹出，然后添加再弹出